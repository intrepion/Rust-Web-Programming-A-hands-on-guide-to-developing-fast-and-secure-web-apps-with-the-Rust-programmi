#[cfg(test)]
mod should {
    use super::*;

    #[test]
    fn succeed_new_given_new_custom_map() {
        let expected = 0;
        let actual = CustomMap::new().body.len();

        assert_eq!(expected, actual);
    }

    #[test]
    fn succeed_insert_and_get_given_integer() {
        let expected = &AllowedData::I(1);

        let mut map = CustomMap::new();
        map.insert("one", AllowedData::I(1));

        let actual = map.get("one");

        assert_eq!(expected, actual);
    }

    #[test]
    fn succeed_insert_and_get_given_string() {
        let expected = &AllowedData::S("one".to_string());

        let mut map = CustomMap::new();
        map.insert("one", AllowedData::S("one".to_string()));

        let actual = map.get("one");

        assert_eq!(expected, actual);
    }
}

use std::collections::HashMap;

#[derive(Debug, PartialEq)]
enum AllowedData {
    I(i8),
    S(String),
}

#[derive(Debug)]
struct CustomMap {
    body: HashMap<String, AllowedData>,
}

impl CustomMap {
    fn new() -> CustomMap {
        return CustomMap {
            body: HashMap::new(),
        };
    }

    fn get(&self, key: &str) -> &AllowedData {
        return self.body.get(key).unwrap();
    }

    fn insert(&mut self, key: &str, value: AllowedData) -> () {
        self.body.insert(key.to_string(), value);
    }

    fn display(&self, key: &str) -> () {
        match self.get(key) {
            AllowedData::I(value) => println!("{}", value),
            AllowedData::S(value) => println!("{}", value),
        }
    }
}

fn main() {
    // defining a new hash map
    let mut map = CustomMap::new();

    // inserting two different types of data
    map.insert("test", AllowedData::I(8));
    map.insert("testing", AllowedData::S("test value".to_string()));

    // displaying the data
    map.display("test");
    map.display("testing");
}
